const isTimeUp = () => {
  var now = new Date();
  return now.getTime() - startTime.getTime() > 30000;
};

const getValueForUpsert = (value, type, codeName, currencyFormat, componentData = null) => {
  switch (type) {
    case "url_slug":
      if (value.length > 0) {
        var mode = "custom";
        if (value === "#autogenerate#") {
          // Revert to autogeneration
          mode = "autogenerated";
        }

        return {
          element: {
            codename: codeName,
          },
          value: value,
          mode: mode,
        };
      }
      return;
    case "text":
      // Cell could contain only numbers, convert to string first
      value = value.toString();
      break;
    case "number": {
      // Convert number string like '1,000.50' or '1 000,50' to float
      value = tryParseNumber(value, currencyFormat);
      break;
    }
    case "rich_text": {
      // Parse special ## macros
      value = parseRichText(value);

      // Load components from the rich_text_components column
      let components = [];
      if (componentData && componentData != '') {
        componentData = JSON.parse(componentData);
        if(!(componentData instanceof Array)) {
          // Components must be an array
          throw new Error('rich_text_components must be an array');
        }
        for (const comp of componentData) {
          if (
            value.includes(
              `object type="application/kenticocloud" data-type="component" data-id="${comp.id}"`
            )
          ) {
            // Rich text contains reference to this component, add to array
            components.push(comp);
          }
        }
      }

      return {
        element: {
          codename: codeName,
        },
        value: value,
        components: components,
      };
    }
    case "asset":
    case "modular_content":
    case "multiple_choice":
    case "taxonomy": {
      // Value should be in format "<identifier type>:<identifier>,<identifier type>:<identifier>"
      // Split into expected format value:[{ <identifier type>: <identifier> }, { <identifier type>: <identifier> }]
      let ar = value.split(",");
      value = [];
      for (var a = 0; a < ar.length; a++) {
        // Individual reference from list
        const record = ar[a].split(":");
        if (record.length === 2) {
          value.push({ [record[0]]: record[1] });
        }
      }
      break;
    }
    case "date_time":
      if (value !== "")
        value = tryFormatDateTime(codeName, value);
      break;
  }

  // Don't upsert empty values
  if (value.length === 0) return;

  return {
    element: {
      codename: codeName,
    },
    value: value,
  };
}

// Format can be 'US' or 'EU'
const tryParseNumber = (number, format) => {
  number = number.toString().trim();
  switch (format) {
    case "US":
      // At the moment, no processing seems to be needed
      // Strings like '1,000.50' are already accepted by Kontent
      break;
    case "EU":
      // Remove inner spaces and dots
      number = number.replace(/\s/g, "").replace(/\./g, "");
      // Replace comma with decimal
      number = number.replace(/,/g, ".");
      break;
  }

  return number;
};

var lut = []; for (var i=0; i<256; i++) { lut[i] = (i<16?'0':'')+(i).toString(16); }
const generateGUID = () => {
  var d0 = Math.random()*0xffffffff|0;
  var d1 = Math.random()*0xffffffff|0;
  var d2 = Math.random()*0xffffffff|0;
  var d3 = Math.random()*0xffffffff|0;
  return lut[d0&0xff]+lut[d0>>8&0xff]+lut[d0>>16&0xff]+lut[d0>>24&0xff]+'-'+
  lut[d1&0xff]+lut[d1>>8&0xff]+'-'+lut[d1>>16&0x0f|0x40]+lut[d1>>24&0xff]+'-'+
  lut[d2&0x3f|0x80]+lut[d2>>8&0xff]+'-'+lut[d2>>16&0xff]+lut[d2>>24&0xff]+
  lut[d3&0xff]+lut[d3>>8&0xff]+lut[d3>>16&0xff]+lut[d3>>24&0xff];
}

// Currently doesn't work for dd/mm/yy
const tryFormatDateTime = (elementCodeName, dateTime) => {
  let date = new Date(dateTime);
  let ret = "";

  try {
    ret = date.toISOString();
  } catch (e) {
    // First failure, could be SQL time like 2017-01-10 15:46:54.5576119
    const t = dateTime.split(/[- :]/);
    date = new Date(Date.UTC(t[0], t[1] - 1, t[2], t[3], t[4], t[5]));

    try {
      ret = date.toISOString();
    } catch (e) {
      // Second failure, could be in format like 11-5-2019, try replace
      dateTime = dateTime.replace(/-/gi, "/");
      date = new Date(dateTime);
      try {
        ret = date.toISOString();
      } catch (ex) {
        errorCounter++;
        upsertResult.errors.push(
          `Error parsing date value of element "${elementCodeName}." Skipping element..`
        );
      }
    }
  }

  return ret;
};

// @ts-ignore
String.prototype.formatUnicorn =
  String.prototype.formatUnicorn ||
  function () {
    "use strict";
    let str = this.toString();
    if (arguments.length) {
      const t = typeof arguments[0];
      const args =
        "string" === t || "number" === t
          ? Array.prototype.slice.call(arguments)
          : arguments[0];

      let key;
      for (key in args) {
        str = str.replace(new RegExp("\\{" + key + "\\}", "gi"), args[key]);
      }
    }

    return str;
  };
